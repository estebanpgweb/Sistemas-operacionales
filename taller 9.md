# 1. Cual es significado del término espera activa?
La espera activa se refiere a un método de sincronización en el que un proceso o hilo continuamente verifica la condición para avanzar o acceder a un recurso compartido. Esto puede llevar a una alta utilización de la CPU, ya que el proceso o hilo consume ciclos de CPU incluso cuando no está realizando ninguna tarea útil, simplemente esperando a que se cumpla la condición.
# 2 De que manera se puede evitar la espera activa?
La espera activa puede evitarse a través de varios mecanismos de sincronización, como semáforos, monitores, señales o bloqueos. Estos mecanismos permiten a un proceso o hilo bloquearse a sí mismo mientras espera que se cumpla una condición, en lugar de verificar activamente la condición. Esto libera los ciclos de CPU para que sean utilizados por otros procesos o hilos.
# 3 Explique por qué los bloqueos mediante bucle sin fin no son apropiados para sistemas monoprocesador, pero se usan con frecuencia en los sistemas multiprocesador.

En un sistema monoprocesador, un bloqueo mediante bucle sin fin no es apropiado porque consume la totalidad del tiempo de CPU de ese único procesador. Cuando un hilo adquiere un bloqueo y entra en un bucle sin fin, se queda esperando hasta que el recurso se libere, verificando repetidamente si está disponible. Mientras tanto, no hay otros hilos que puedan ejecutar en el sistema, ya que solo hay un procesador. Esto resulta en una utilización ineficiente de los recursos, ya que el tiempo de CPU se desperdicia en espera activa en lugar de realizar otras tareas útiles.

En cambio, en sistemas multiprocesador, donde hay varios procesadores disponibles, los bloqueos mediante bucle sin fin son más utilizados ya que los otros hilos pueden seguir ejecutándose en los procesadores restantes. Esto permite una mejor utilización de los recursos de la CPU, ya que los hilos que no necesitan el recurso bloqueado pueden ejecutarse simultáneamente en otros procesadores.
# 4 Explique por qué las interrupciones no son apropiadas para implementar primitivas de sincronización en los sistemas multiprocesador.

En lugar de utilizar interrupciones, los sistemas multiprocesador suelen implementar otras primitivas de sincronización más adecuadas, como los bloqueos, semáforos o variables de condición, que garantizan la exclusividad de recursos y proporcionan mecanismos eficientes para resolver problemas de coherencia de caché en un entorno multiprocesador, las interrupciones no son apropiadas para implementar primitivas de sincronización en sistemas multiprocesador por diferentes razones; una de ellas es porque no garantizan la exclusividad de recursos compartidos entre múltiples procesadores. En un sistema multiprocesador, varios hilos pueden ejecutarse simultáneamente en diferentes núcleos y acceder a recursos compartidos. Si se utiliza una interrupción para sincronizar el acceso a un recurso, no hay garantía de que solo un hilo tenga acceso exclusivo a ese recurso en un momento dado, además las interrupciones no garantizan la exclusividad de recursos compartidos entre múltiples procesadores en un sistema multiprocesador, varios hilos pueden ejecutarse simultáneamente en diferentes núcleos y acceder a recursos compartidos. Si se utiliza una interrupción para sincronizar el acceso a un recurso, no hay garantía de que solo un hilo tenga acceso exclusivo a ese recurso en un momento dado.
# 5. Describa cómo se puede utilizar la instrucción swap() para proporcionar un mecanismo de exclusión mutua que satisfaga el requisito de espera limitada.

La instrucción swap() se puede utilizar para implementar un bloqueo de exclusión mutua mediante la alternancia de un valor en una variable compartida. Un proceso o hilo puede utilizar swap() para cambiar el valor de la variable a un valor que indica que está ocupado antes de entrar en una sección crítica. Si otro proceso o hilo intenta hacer lo mismo, verá que el valor ya ha cambiado y se bloqueará o entrará en espera activa. Este mecanismo garantiza que solo un proceso o hilo puede entrar en la sección crítica a la vez, cumpliendo así el requisito de espera limitada.
# 6. Los servidores pueden diseñarse de modo que limiten el número de conexiones abiertas. Explique cómo puede utilizar un servidor los semáforos para limitar el número de conexiones concurrentes.
Un semáforo se puede utilizar para controlar el acceso a un recurso limitado, como las conexiones a un servidor. El servidor inicializa un semáforo con el número máximo de conexiones que puede manejar concurrentemente. Cada vez que se establece una nueva conexión, el servidor decrementa el semáforo. Si el semáforo está en cero, lo que indica que todas las conexiones posibles están en uso, los nuevos clientes tendrán que esperar hasta que se libere una conexión. Cuando se cierra una conexión, el servidor incrementa el semáforo, lo que permite que se establezca una nueva conexión.
# 7.  Demuestre que los monitores y semáforos son equivalentes, en cuanto a que se pueden emplear para implementar los mismos tipos de problemas de sincronización
Los monitores y semáforos se pueden utilizar para resolver los mismos tipos de problemas de sincronización, aunque lo hacen de maneras diferentes un semáforo es una variable que se utiliza para controlar el acceso a un recurso compartido a través de operaciones de incremento (signal) y decremento (wait). Por otro lado, un monitor es un constructo de programación que encapsula los datos compartidos y los métodos para acceder a esos datos de una manera que garantiza la exclusión mutua, por ejemplo, podríamos implementar un buffer limitado tanto con semáforos como con monitores. Con semáforos, tendríamos un semáforo para controlar el acceso al buffer y otro para controlar el número de elementos en el buffer. Con un monitor, tendríamos un método para añadir un elemento al buffer y otro para extraer un elemento, y ambos garantizarían la exclusión mutua.
# 8 La exclusión mutua estricta en un monitor hace que el monitor de búfer limitado sea adecuado para porciones pequeñas. Explique por qué es cierto esto.
La exclusión mutua estricta en un monitor implica que, si un hilo está ejecutando una porción grande de código dentro del monitor, otros hilos deben esperar hasta que ese hilo haya finalizado su ejecución y haya liberado el monitor.

Cuando se trata de un monitor de búfer limitado, donde hay un límite en la cantidad de elementos que se pueden almacenar en el búfer, es importante minimizar el tiempo que cada hilo pasa dentro del monitor para evitar bloqueos prolongados y maximizar la concurrencia. Esto se debe a que, si un hilo está ocupando el monitor durante mucho tiempo, otros hilos pueden estar esperando para acceder al búfer limitado, lo que puede resultar en una baja eficiencia y un rendimiento deficiente.

# 9 Por qué Windows y Linux utilizan bloqueos mediante bucle sin fin como mecanismo de sincronización solo en los sistemas multiprocesador y no en los sistemas monoprocesador?
Tanto Windows como Linux utilizan bloqueos mediante bucle sin fin, también conocidos como spinlocks, como mecanismos de sincronización en sistemas multiprocesador, pero no en sistemas monoprocesador, debido a que en un sistema monoprocesador, donde solo hay un único procesador, utilizar un bloqueo mediante bucle sin fin resulta en una utilización ineficiente de los recursos. Cuando un hilo adquiere un bloqueo y entra en un bucle sin fin, se queda esperando activamente hasta que el recurso se libere, sin permitir que otros hilos ejecuten sus tareas. Esto desperdicia el tiempo de CPU, ya que no se están realizando tareas útiles mientras se espera, también en un sistema multiprocesador, donde hay múltiples procesadores disponibles, el uso de bloqueos mediante bucle sin fin puede ser más efectivo. Cuando un hilo adquiere un bloqueo y entra en un bucle sin fin, otros hilos pueden seguir ejecutándose en los procesadores restantes, lo que aprovecha la concurrencia y la capacidad de ejecutar tareas en paralelo.
